# 1일차 

## HTTP METHOD

### GET(read)

- 리소스 조회 메서드
- 쿼리스트링을 통해 데이터를 전달
    - ex) localhost/members/1?username=inpa&height=200
- 쿼리스트링 외에 메시지 바디를 사용해서 데이터를 전달할 수 있지만 서버에서 따로 구성해야 되기 때문에 지원하지않는 곳이 많아 권장하지 않음
- POST를 사용해도 되지만 캐싱이 불가능해서 GET을 사용

### POST(create)

- 전달한 데이터 처리/생성 요청 메서드
- 메시지 바디를 통해 데이터를 전달
- 만약 데이터 조회를 위해 JSON으로 데이터를 넘겨야 하는 경우 POST 사용

### PUT(update)

- 리소스를 수정하는 메서드
- 요청 메시지에 리소스가 있으면 덮어쓰고, 엎으면 새로 생성
    - ex) /member/100
- 데이터를 대체해야 하기 때문에, 리소스의 구체적인 경로를 보내줘야 함
    - ex) POST /members 멥버 새로 추가 PUT /members/1 1번 멥버 수정

### PATCH(update)

- 리소스의 부분을 수정하는 메서드
- 만약 PATCH를 지원하지 않는 서버라면 POST 사용

### DELETE(delete)

- 리소스를 제거하는 메서드

### HEAD

- GET과 동일하지만 서버에서 Body를 Return 하지 않음
- 응답의 상태 코드만 확인하는 경우 Resource를 받지 않고 오직 찾기만 원할때 사용(검사용)
- 서버의 응답 헤더를 확인해서 Resource가 수정 되었는지 확인 가능

### TRACE

- 검사용 메서드
- 서버에 도달 했을 때의 최종 패킷의 요청 패킷 내용을 받을 수 있음
- 요청의 최종 수신자는 반드시 송신자에게 수신한 메시지와 200을 Body로 보냄
- 최초 Clinet의 요철에는 Body가 포함될 수 없음

### OPTION

- 예비 요청에 사용되는 메서드
    - 예비 요청이란 본 요청을 하기 전에 안전한지 미리 검사하는 것
- 서버의 지원 가능한 HTTP 메서드와 출처를 받아 CORS 정책을 검사함

#### CORS(Cross Origin Resource Sharing)

- 교차 출처 리소스 공유 정책으로 다른 출처의 리소스 공유에 대한 허용/비허용 정책
- 출처는 프로토콜,도메인,포트만 비교
- 기본 동작 과정
    1. 클라이언트가 HTTP요청(예비 요청) 헤더에 Origin을 담아 서버에 전달
    2. 서버가 응답헤더에 Access-Control-Allow-Origin을 담아 클라이언트에 전달
    3. 클라이언트가 Origin과 Access-Control-Allow-Origin를 비교
- 프록시 서버를 사용해서 해결 가능

## HTTP 상태 코드

### 1XX(정보 제공)

- 임시 응답으로 현재 클라이언트의 요청까지는 처리되었으니 계속 진행하라는 의미(HTTP 1.1 버전부터 추가)

### 2XX(성공)

- 클라이언트의 요청이 서버에서 성공적으로 처리
- *200 성공*
- *201 요청이 처리되어 리소가 생성*
- *202 요청은 접수하였지만, 처리가 완료되지 않음*

### 3XX(리다이렉션)

- 완전한 처리를 위해서 추가 동작이 필요한 경우
- 주로 서버의 주소 또는 요청한 URL의 웹 문서가 이동되었으니 그 주소로 다시 시도하라는 의미
- *301 새로운 URL로 영구 이동*
- *303 다른 위치로 요청*
- 304 마지막 요청이후 페이지가 수정되지 않음
- *307 임시로 리다이렉션 요청*

### 4XX(클라이언트 에러)

- 없는 페이지를 요청하는 등 클라이언트의 요청 메시지 내용이 잘못된 경우를 의미
- *400 잘못된 요청*
- *401 지정한 리소스에 대한 권환이 없음*
- *403 401 인증 처리 이외 엑세스가 금지됨*
- *404 찾을 수 없음*

### 5XX(서버 에러)

- 서버 사정으로 메시지 처리에 문제가 발생한 경우
- 서버의 부하, DB 처리 과정 오류, 서버에세 Exception이 발생하는 경우
- *500 서버 내부 오류*
- *501 구현되지 않음*
- *502 게이트웨이 또는 프록시 서버가 잘못됨*

## HTTP 헤더

### 공통 헤더

- 요청 및 응답 메시지 모두에서 사용 가능한 기본적인 헤더
- Date HTTP 메시지를 생성한 일시
- Connetion 클라언트와 서버 간 연결에 대한 옵션 설정
- Cache-Control 쿠키 캐시 관련

### 엔티티 관련 헤더

- 요청 및 응답 메시지 모두에서 사용 가능한 Entity에 대한 설명 헤더
- Content-Type 해당 개체에 포함되는 미디어 타입 정보
- Content-Language 헤더 개체와 가장 잘 어울리는 언어
- Content-Encoding 해당 개체 데이터의 압축 방식
- Content-Length 해당 개체의 바이트 길이 또는 크기
- Content-Location 해당 개체의 실제 위치
- Content-Disposition 응답 Body를 브라우저가 어떻게 표시해야 하는지
- Content-Disposition 외부 파일을 불러오는 경우, 차단할 소스와 불러올 소스 명시
- Location 리다이렉트 된 때에 이동된 주소, 또는 새로 생성된 주소를 명시
- Last-Modified 리소스를 마지막으로 갱신한 일시
- Transfer-Encoding 동적으로 생서되어 Body의 길이를 모르는 경우 조금씩 전송 가능한 청크

### 요청 헤더

- Host 요청하는 호스트명과 포트번호(필수)
- User-Agent 클라이언트 소프트웨어 정보
- From 클라이언트 사용자 메일 주소
- Cookie 서버에 의해 클라이언트에 설정된 쿠키 정보
- Referer 바로 직전에 머물었던 링크 주소
- If-Modified-Since 제시한 일시 이후로만 변경된 리소스 취득 요청
- Authorization 인증 토큰을 서버로 보냄


### 응답 헤더 캐시/쿠키 관련 헤더

- 특정 유형의 HTTP 요청이나 특정 HTTP 헤더를 수신했을 때, 이에 응답
- Server 서버 소프트웨어 정보
- Set-Cookie 서버측에서 클라인어트에게 세션 쿠키 정보를 설정 (캐시/쿠키)
- Expires 응답 컨텐츠가 언제 만료되는지 나타냄 (캐시/쿠키)
- Age 캐시 응답. max-age 시간 내에서 얼마나 흘렀는지 초 단위로 알려줌 (캐시/쿠키)
- ETag HTTP 컨텐츠가 바뀌었는지를 검사 (캐시/쿠키)
- Allow 서버 측에서 지원 가능한 HTTP메서드의 리스트
- Access-Control-Allow-Origin 요청을 보내는 프론트 주소와 받는 백엔드 주소가 다르면 CORS에러 발생

## REST API

- API 설계에 대한 표준이 없어서 구축과 디버깅이 어려워 개발됨
- HTTP 프로토콜을 기반으로 하는 웹 통신을 위한 아키텍처 스타일 
- REST(Representational State Transfer) 자원을 이름으로 구분하여 해당 자원의 상태를 주고 받는 모든 것을 의미

### 주요 특징

- 어떤 플랫폼이나 언어를 사용하더라도 HTTP 프로토콜을 통해 통신이 가능
- API 메세지만으로도 의도를 명확하게 파악 가능
- 서버가 클라이언트의 상태를 저장하지 않아 서버 확장이 용이하며 독립적인 개발 가능
- 로드 밸런서, 캐시등의 중간 계층을 추가하여 시스템을 확장 가능
- 필요한 리소스만 요청하고 응답받아 불필요한 데이터 전송 방지
- HTTP 캐싱 기능을 활용하여 응답시간 개선과 서버 부하를 줄임
- HTTP의 SSL/TLS를 통한 암호화 지원
- 헤더나 토근을 통한 접근 제어 가능

### 단점

- HTTP 메서드에 제한적
- 공식적인 표준의 부재로 인한 일광성 있는 API 설계 어려움

### RESTFUL

- REST의 특징을 따라가는 것(얼마나 REST API를 잘 지키냐)
- 클라이언트와 서버가 분리되어 독립적으로 개발이 가능해야 함
- 각 요청은 독립적으로 모든 요청에는 요청을 처리하는데 필요한 모든 정보가 포함되어야 함

## 쿠키와 세션, JWT토큰

### 쿠키

- 서버가 클라이언트의 웹 브라우저에 저장하는 작은 데이터
- 최대 4KB까지의 문자열 데이터 저장 가능
- 클라이언트 측에 저장
- 만료기간 설정 가능
- 도메인 별로 저장됨
- HTTP 헤더에 포함되어 전송

### 세션

- 서버 측에서 유지되는 사용자별 상태 정보
- 세션 ID를 통해 클라이언트 식별
- 서버 측에 저장
- 브라우저 종료 시 삭제
- 보안성이 쿠키보다 높음
- 서버 리소스 사용

### 쿠키와 세션 필요 이유

- HTTP 프로토콜의 특성인 비연결성과 무상태성을 보안하기 위해 필요
- 서버가 클라이언트를 식별하고 이전 요청과의 연속성을 유지할 수 있음
- 사용자별 맞춤 서비스 제공이 가능
- 로그인 상태 유지, 장바구니 등의 정보를 관리할 수 있음
- 쿠키를 사용하면 클라이언트 측에서 정보를 저장하여 서버 부하를 줄일 수 있음
- 세션을 통해 중요 정보를 서버에서 안전하게 관리

### JWT(JSON Web Token)

- 정보를 안전하게 JSON 객체로 전송하기 위한 독립적인 토큰

#### 기존 세션 방식의 문제 해결

- 별도의 세션 저장소가 필요 없어서 서버 확장이 쉬움
- 사용자 인증을 위한 추가 리소스 비용 감소

#### 구조

- 헤더 : 토큰 유형과 사용된 암호화 알고리즘 정보 포함
- 페이로드 : 사용자 정보 및 권한 정보 포함, 토큰 발급/만료 시간 등의 클레임 정보
- 서명 : 토큰의 유효성을 검증하기 위한 서명

#### 작동 방식

1. 클라이언트가 로그인 요청
2. 서버가 인증 정보를 확인
3. 인증 성공시 JWT 토큰 생성
4. 생성된 토큰을 클라이언트에게 반환
5. 이후 클라이언트는 모든 API 요청시 JWT를 Authorization 헤더에 포함
6. 서버는 JWT 검증 필터를 통해 토큰 유효성 검사
7. 검증 성공 시 요청한 리소스에 접근 허용


#### 단점

- Base64 인코딩으로 인한 데이터 크기 증가
- 토큰 탈취 시 만료 전까지 대체 어려움
- 중요 정보를 페이로드에 저장할 수 없음

## MVC, MVC2 (Mode View Controller)

### MVC1 아키텍처

- JSP 페이지가 Controller와 View 역활을 모두 담당
- 하나의 JSP 페이지 내에서 비즈니스 로직과 화면 표시를 모두 처리
- Model은 JavaBeans를 통해 데이터 처리

#### 장점

- 구현이 단순하고 빠른 개발 가능
- 소규모 프로젝트에 적합

#### 단점

- 코드의 가독성이 떨어짐
- 유지보수가 어려움
- 컴포넌트 재사용성이 낮음

### MVC2 아키텍처

- Controller(Servlet), View, Model이 명확히 분리됨
- Controller가 모든 요청을 처리하고 Model과 View를 조정
- View는 순수하게 화면 표시만 담당
- UI 와 비즈니스 로직이 완전히 분리
- 각 계층이 독립적으로 개발/수정 가능
- 컴포넌트의 재사용이 용이

## HTTPS

- HTTPS는 HTTP의 보안 확장 버전으로 SSL/TLS 프로토콜을 통해 암호환된 통신을 제공

### 주요 기능

- 모든 통신 내용을 SSL/TLS 프로토콜로 암호화
- 전송 중에 데이터 변조 방지
- SSL 인증서를 통한 서버 신원 확인

### 작동 방식

1. 초기 연결 설정 (HandShking)
     - 클라이언트가 서버에 연결 시도
     - 서버가 SSL 인증키 전달
     - 클라이언트가 인증서 유효성 검증
2. 세션키 교환
    - 클라이언트가 세션키 생성
    - 서버의 공개키로 세션키를 암호화하여 전송
    - 서버가 개인키로 복호화하여 세션키 획득
3. 데이터 통신
    - 공유된 세션키를 사용하여 데이터 암호화/복호화
    - 양방향 암호화된 통신 수행

### HTTPS 적용을 위해 웹 서버를 사용하는 이유

- 웹 서버를 사용하면 애플리케이션 서버는 비즈니스 로직에만 집중할 수 있고, 보안과 성능 최적화는 웹 서버가 전문적으로 처리할 수 있음 이로인해 전체 시스템의 효율성과 안정성을 높이는 결과를 가져옴

## DNS(Domain Name System) 서버

- DNS 서버는 도메인 이름을 IP주소로 변환해주는 인터넷의 전화번호후 역활을 하는 시스템
    - ex) www.example.com -> 192.158.1.38

### 필요 이유

- 복잡한 IP주소 대신 기억하기 쉬운 도메인 사용
- DNS 캐싱을 통한 빠른 웹사이트 접근
- 서버 부하 분산
- 네트워크 트래픽 최적화
- IP 주소가 변경되어도 도메인 이름으로 유지 가능

### DNS 서버 계층

1. LOCAL DNS SERVER
2. ROOT DNS SERVER
3. TLD(Top Level Domain) SERVER
4. Authoritative DNS Server

### DNS 캐싱

1. 브라우저 캐시
2. 운영체제 캐시
3. ISP 캐시

## CI/CD (Continuous Integration/Continuous Delivery)

- 애플리케이션의 개발 단계를 자동화하여 애플리케이션을 더욱 짧은 주기로 고객에게 제공하는 방법입니다.

### CI

- 개발자들이 코드 변경사항을 중앙 레포지토리에 자주 병합
- 자동화된 빌드 및 테스트 수행
- 코드 품질 유지 및 버그 조기 발견

### CD

- 테스트를 통과한 코드를 자동으로 배포 준비
- 포로덕션 환경으로 자동 배포
- 안정적이고 빠른 릴리스 가능