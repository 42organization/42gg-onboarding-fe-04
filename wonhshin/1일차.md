## HTTP

  <hr/>
- hypertext transfer protocol
- 네트워크 장치 간의 정보를 전송하는데 사용되는 프로토콜
  - 웹에서 클라이언트와 서버간의 데이터를 주고받기 위해 설계된 프로토콜
- 클라이언트가 요청하기 위해 연결을 연 다음 응답을 받기 까지 대기하는 클라이언트-서버 모델을 따름

### HTTP 메소드 종류

<hr/>

**중요메소드**

| 메소드 | 설명                                                                              |
| :----- | :-------------------------------------------------------------------------------- |
| GET    | 리소스 조회 메소드                                                                |
| POST   | 클라이언트가 서버로 데이터 전송을 하여 리소스 생성하거나 처리하도록 요청하는 과정 |
| PUT    | 리소스를 대체하는 메소드, 일부 변경시에는 PATCH 사용                              |
| PATCH  | 리소스 일부분을 변경하는 메소드                                                   |
| DELETE | 리소스 제거 메소드                                                                |

### 중요메소드 상세기술

**GET**

> 정적 데이터 조회과정

1. 이미지, 정적 테스트 문서 get
2. 쿼리 파라미터 없이 리소스 경로로 단순하게 조회 가능

> 동적 데이터 조회과정
>
> 1. 쿼리 파라미터를 사용해 데이터 전달
> 2. 쿼리 파라미터로 상세한 조회 데이터 얻을 수 있음

**POST**

> 동작 흐름

1. 클라이언트의 요청 준비

- 클라이언트는 데이터를 준비하고 POST요청 생성, 데이터는 본문에 포함됨

2. 클라이언트가 서버로 요청 전송

- 요청 본문에 포함된 데이터가 서버로 전달됨

3. 서버가 요청 처리

- 서버는 요청 데이터를 수신,파싱하여 비즈니스 로직 실행
- 데이터 베이스에 리소스를 생성하거나 필요한 작업 수행

4. 서버가 클라이언트로 응답

- 요청 처리 결과를 HTTP응답으로 반환
- 성공시 201, 실패시 400 상태 코드 변환

5. 클라이언트의 응답처리

** PUT**

> 요청 메세지에 리소스가 있으면 덮어쓰고 생성함
> PUT 요청에 일부 리소스만 변경하기 원한다면, 모든 데이터를 작성해서 보내야함

**PATCH**

> PATCH 지원이 안되면 대신 POST사용도 가능

### 그 외 메소드

| 메소드 | 설명                                                                          |
| :----- | :---------------------------------------------------------------------------- |
| HEAD   | 응답 상태 코드 확인 시 사용 BODY를 Return하지 않음                            |
| TRACE  | 검사용 메소드, 서버에 도달했을 때 최종 패킷의 요청 패킷 내용 응답받을 수 있음 |
| OPTION | 서버의 지원 가능한 HTTP메소드와 출처를 응답받아 CORS정책을 검색하기 위한 요청 |

### HTTP 메서드와 멱등성

---

- **멱등성** | 같은 작업을 여러 번 반복해서 실행해도 결과가 변하지 않는 성질을 의미
  > HTTP의 멱등성
  > 요청을 몇 번 반복해도, 서버 상태와 응답이 동일해야함

* **GET** | 데이터를 조회하는 요청이므로 반복 실행해도 서버의 상태가 변하지 않음
* **PUT** | 자원을 특정 상태로 업데이트 하므로, 동일한 요청을 여러 번 보내도 상태가 바뀌지 않음
* **DELETE** | 이미 삭제된 리소스에 대해 반복 호출해도 삭제됨으로 유지됨

- 비멱등한 메서드
- **POST** | 새 리소스를 생성하는 요청이므로, 동일한 요청을 반복하면 리소스가 여러개 생성되며 반복 호출 시 서버 상태가 변경됨

## CORS

<hr/>

- 한 출처(origin)의 클라이언트(브라우저)가 다른 출처의 리소스에 접근할 수 있도록 허용하기 위한 HTTP기반 매커니즘
- 프로토콜, 호스트, 포트로 구성
- 기본적으로 브라우저는 같은 출처에서만 리소스를 요청하고 응답을 허용하기에, 다른 출처에 요청을 보낼 경우 서버가 **명시적으로 허용하지 않으면 <span style="color:red">CORS에러 발생**

### CORS 에러 해결 방법

1. 서버에 CORS 허용 설정
2. Spring에서 허용
3. 프록시 서버 사용

## HTTP 상태 코드표

---

서버에서의 처리결과는 응답 메세지의 상태라인에 있는 상태 코드를 보고 파악할 수 있음

** 1xx: 정보제공 **

| 상태코드 | 텍스트      | 의미                                            |
| :------- | :---------- | :---------------------------------------------- |
| 1xx      | information | 클라이언트의 요청을 받았으며 작업을 계송 진행함 |

** 2xx: 성공 **

| 상태코드 | 텍스트   | 의미                                                                    |
| :------- | :------- | :---------------------------------------------------------------------- |
| 2xx      | success  | 클라이언트가 요청한 동작을 수신하여 이해했고 승낙하여 성공적으로 처리함 |
| 200      | OK       | 서버가 요청을 성공적으로 처리함                                         |
| 201      | Creatd   | 요청이 처리되어 새로운 리소스 생성                                      |
| 202      | Accepted | 요청은 접수하였지만, 처리가 완료되지 않음                               |

** 3xx: 리다이렉션 **

| 상태코드 | 텍스트              | 의미                                               |
| :------- | :------------------ | :------------------------------------------------- |
| 3xx      | Redirection         | 클라이언트는 요청을 마치기 위해 추가 동작을 해야함 |
| 300      | Multiple permanetly | 선택항목이 여러개 있음                             |
| 301      | Moved Permanently   | 지정한 리소스가 새로운 URL로 이동함                |
| 303      | See Other           | 다른 위치로 요청함                                 |
| 304      | Not Modified        | 마지막 요청 후 요청 페이지는 수정되지 않음         |
| 307      | Temporary Redirect  | 임시로 리다이렉션 요청이 필요함                    |

** 4xx: 클라이언트 에러 **

| 상태코드 | 텍스트       | 의미                                    |
| :------- | :----------- | :-------------------------------------- |
| 4xx      | Client Error | 클라이언트는 요청에 에러가 있음         |
| 401      | Unauthorized | 지정한 리소스에 대한 액세스 권한이 없음 |
| 403      | Forbidden    | 지정한 리소스에 액세스 금지되었음       |
| 404      | Not Found    | 지정한 리소스를 찾을 수 없음            |

** 5xx: Server Error **

| 상태코드 | 텍스트              | 의미                                                                                 |
| :------- | :------------------ | :----------------------------------------------------------------------------------- |
| 5xx      | Server Error        | 클라이언트의 요청은 유효한데 서버가 처리를 실패함                                    |
| 501      | Not implemented     | 요청한 URI 메소드에 대해 서버가 구현하고 있지 않음                                   |
| 502      | Bad Gateway         | 게이트웨이 또는 프록시 역할을 하는 서버가 뒷단의 서버로부터 잘못된 응답을 받음       |
| 503      | Service Unavailable | 현재 서버에서 서비스를 제공할 수 없음                                                |
| 504      | Gateway Timeout     | 게이트웨이 또는 프록시 역할을 하는 서버가 서버로부터 응답을 기다리다가 타임아웃 발생 |

</br>

## HTTP 헤더

---

**공통헤더**

- DATE: 메세지 생성 시간 제공

- Connection: 연결 유지 여부 제어

- Cache-Control: 캐싱정책제어

- Pragma: 캐싱관련지시

- Trailer: 청크 인코딩 시 본문 이후 제공될 추가 헤더 정의

** Cache-control ** - cache-control : no-store

- 아무 것도 캐싱하지 않음
  - cache-control : no-cache
    - 모든 캐시를 쓰기 전에 서버에 해당 캐시를 사용해도 되는 지 확인
  - cache-control : must-revalidate
    - 만료된 캐시만 서버에 확인을 받음
  - cache-control: public
    - 공유 캐시에 저장해도 되는 것을 의미
  - cache-control : private
    - 브라우저 같은 특정사용자 환경에만 저장
  - cache-control : max-age
    - 캐시 유효시간을 명시

* expires
  - 리소스가 지정된 일시까지 캐시로써 유효함을 나타냄. 즉, 응답 컨텐츠가 언제 만료되는 지 나타냄

## 쿠키🍪와 세션

---

> HTTP 프로토콜의 특징

- 비연결 지향
- 상태정보 유지 안함

- 쿠키와 세션은 HTTP의 요청 간 **의존관계가 없기 때문에**, 현재 접속한 사용자가 이전에 접속한 사용자와 같은 사용자인 지 알 수가 없음
- 계속해서 연결을 유지하지 않기 때문에 통신할 때마다 새로 연결하기 때문에, 클라이언트는 매 요청마다 인증해야함6bt6tb
- 이전 요청과 현재 요청이 같은 사용자의 요청인 지 알기 위해 상태를 유지해야함

### 쿠키

- 개념
  - **클라이언트 로컬**에 저장되는 키와 값이 들어있는 파일
  - 이름, 값, 유효시간, 경로 포함
  - 클라이언트의 상태 정보를 브라우저에 저장하여 참조
- 동작방식
  - 웹 브라우저가 서버에 요청
  - 상태를 유지하고 싶은 값을 쿠키로 생성
  - 서버 응답시 HTTP헤더(set-cookie)에 쿠키 포함하여 전송
  - 전달받은 쿠키는 웹 브라우저에서 관리하다가, 다음 요청 때 쿠키를 HTTP헤더에 넣어 전송

### 세션

- 개념
  - 일정 시간 동안 같은 브라우저로 들어오는 요청을 하나의 상태로 보고 그 상태를 유지하는 기술
  - 즉, 웹 브라우저를 통해 서버에 접속한 이후부터 브라우저를 종료할 때 까지 유지하는 상태
  - **서버가 데이터 저장**하고 있음
- 동작방식
  - 웹 브라우저가 서버에 요청
  - 서버가 해당 웹 브라우저에 ID부여
  - 서버가 응답할 때 HTTP헤더에 session ID포함하여 전송
  - 웹 브라우저는 창을 닫기까지 다음 요청 때 부여된 session ID가 담겨있는 쿠키를 HTTP헤더에 넣어서 전송
  - 서버는 세션id 확인 후 응답
  - 서버도 쿠키를 사용하여 값을 주고 받음
- 특징
  - 서버를 데이터에 저장하기 때문에 클라이언트가 직접 데이터를 조작할 수는 없지만, 서버 자원의 한계가 있으므로 메모리 사용 시 속도저하가 올 수 있다

### 브라우저 저장소

---

- Local Storage
- Session Storage
- Cookie

> 쿠키는 브라우저에 사용자 정보가 기록되기에 위변조의 가능성이 높아 보안에 취약하며, 세션은 서버의 메모리를 차지하기에 서버 과부하의 원인이 된다.
> 이와 같은 이유로, 보호할 데이터를 토큰으로 치환하는 <span style="red">**토큰 기반의 인증방식**</span>이 도입된다.

## JWT

###### JSON Web Token

---

인증 및 정보 전달을 위해 클라이언트와 서버 간에 안전하게 데이터를 교환하는 서명된 토큰

- 정보가 담긴 데이터를 암호화하여, HTTP헤더에 추가함 => 보안성 증가
- 권한에 부여하기 위한 필요 데이터가 JWT안에 있으므로, OAuth처럼 인증 서버에서 토큰에 대한 정보를 찾을 필요가 없음

> OAuth란?
> 다른 웹 서비스의 계정으로 사용자 인증을 대신하는 토큰 기반의 사용자 인증 기술

### JWT 구조 및 생성

---

> header + payload + signature

![](https://velog.velcdn.com/images/wondi/post/c7054a78-39f4-4f4f-9dd4-d4b4490e79e0/image.png)

헤더

- type: 토큰 타입 명시
- algo: 해싱 알고리즘
  내용
- 토큰에 대한 정보 작성
- 정보는 속성, 값으로 표현함(claim)
  - registered claim: iss, exp, sub, aud
    서명
- 헤더의 인코딩 값과 내용의 인코딩값을 "."로 연결하여 합친 후 비밀키로 해싱

![](https://velog.velcdn.com/images/wondi/post/819e4faf-b3bb-4f3a-85f4-dde3a41a8e57/image.png)

### 쿠키기반과 JWT 동작방식

![](https://velog.velcdn.com/images/wondi/post/831468fb-7c5a-4eb2-81ad-e606a6a4e15d/image.png)

- 쿠키 기반 동작

![](https://velog.velcdn.com/images/wondi/post/cf0c22a6-e60b-46dc-ab91-0e947de5894a/image.png)

- JWT 동작

## MVC & MVC2

---

> MVC란 model, view, controller의 약자이며 각 레이어간의 기능을 구분하는데 중점을 둔 디자인 패턴

- **model** : 데이터 관리, 비즈니스 로직을 처리하는 부분(DAO, DTO, Service)
- **view** :비즈니스 로직의 처리 결과를 통해 유저 인터페이스가 표현되는 구간(html, jsp, tymeleaf)
- **Controller** : 사용자의 요청을 처리하고 model과 view를 중개하는 역할
  - mvc 패턴에서는 view와 model이 직접적인 상호소통을 하지 않도록 관리함

### MVC1

![](https://velog.velcdn.com/images/wondi/post/75826814-e519-4a3b-b841-2b2cf55671f0/image.png)

- mvc1패턴은 view, controller 역할을 모두 JSP가 담당함
  - JSP가 중심으로 요청을 받고, 비즈니스 로직 처리 결과를 사용자에게 출력하는 역할(view)과 요청을 처리하는 역할(Controller) 모두 수행
  - 분리 부족: model, view, controller의 역할이 구분되지 않아 코드가 복잡해지고 유지보수가 어려움

> 클라이언트 요청 -> JSP가 직접 데이터베이스 접근, 비즈니스 로직처리 -> 결과를 JSP내부에서 출력

### MVC2

![](https://velog.velcdn.com/images/wondi/post/9d800cff-9d06-4a5f-b9c1-78a8c9f9f0f4/image.png)

- mvc2 패턴은 요청을 컨트롤러(Servlet)가 먼저 받음
  - 즉, Controller와 View가 분리됨
- DispatcherServlet = Front Controller가 우선적으로 유저의 요청을 받고, 요청을 분석하여 세부 컨트롤러들에게 필요한 작업 나눠줌
- 요청에 매핑되는 컨트롤러 검색 요청
- 컨트롤러에 처리 요청
- 컨트롤러의 처리 결과를 생성할 뷰를 결정
- 결과 화면 리턴

> 작동방식 1. 클라이언트는 URL을 통해 요청을 전송함 2. 디스패처 서블릿은 핸들러 매핑을 통해 해당 요청이 어느 컨트롤러에 온것인지 온 건지 확인함 3. 디스패처 서블릿은 핸들러 어댑터에게 요청의 전달을 맡김 4. 핸들러 어댑터는 해당 컨트롤러에 요청 전달 5. 컨트롤러는 비즈니스 로직을 처리한 후 반환할 뷰의 이름 반환 6. 디스패처 서블릿은 뷰 리졸버를 통해 반환 뷰를 찾음 7. 디스패처 서블릿은 컨트롤러에서 뷰에 전달할 데이터 추가함 8. 데이터가 추가된 뷰 반환

## HTTPS

---

**hypertext transfer protocol secure**: 웹에서 데이터를 안전하게 전송하기 위해 사용되는 HTTP 보안버전

- TLS/ SSL 프로토콜을 사용하여 암호화 구현함

### HTTP와 HTTPS의 차이점

---

- HTTP는 보안이 없는 프로토콜이고, HTTPS는 데이터를 암호화하여 보안을 강화한 프로토콜이다.

| 항목       | HTTP                     | HTTPS                           |
| :--------- | :----------------------- | :------------------------------ |
| 보안       | 암호화 없음              | 데이터 암호화로 보안 강화       |
| 포트       | 80번 포트 사용           | 443번 포트 사용                 |
| 인증       | 서버 인증 없음           | SSL/TLS 인증서로 서버 인증 가능 |
| 데이터보호 | 데이터가 평문으로 전송됨 | 데이터를 암호화해 전송          |

## DNS

---

Domain Name System
도메인이름을 ip주소로 변환해주는 서버

- 사용편의성
- 유연한 관리
  - ip주소가 바뀌더라도, 도메인 이름은 유지됨
- 빠른 접속속도
  - 캐싱메커니즘으로 자주 사용하는 도메인을 캐싱하여, 더 빠르게 사이트에 접속 가능
- 부하 분산 지원
  - 여러 서버에 트래픽 분산, 대규모 서비스에서도 안정적인 접속을 유지할 수 있도록 함(하나의 도메인에 여러 ip주소 매핑)

## CI/CD

---

소프트웨어 개발에서 자동화된 빌드, 테스트, 배포 프로세스를 통해 코드를 빠르고 안정적으로 배포할 수 있도록 도와주는 접근 방식

### CI (Continuous Integration)

**지속적 통합** : 개발자가 작성한 코드를 정기적으로 통합하여 빌드하고 테스트하는 과정

### CD (Continuous Deployment)

**지속적 배포** : 테스트를 통과한 코드를 자동으로 프로덕션에 배포

> CI/CD는 소프트웨어 개발 과정에서 코드 통합, 테스트, 배포를 자동화하여 품질과 속도를 동시에 향상시키는 프로세스

## REST API

---

클라이언트와 서버간에 http 프로토콜, 데이터를 주고 받는 방식을 정의한 것

- HTTP 메서드 사용
- URI로 자원 식별
- 무상태성
- 표준화된 데이터 포맷(예) JSON)
- 계층적 구조

### RESTFUL

> CRUD를 잘 지키는 것

###### 출처

---

[생활코딩 JWT](https://www.youtube.com/watch?v=36lpDzQzVXs)
[MVC패턴 블로그](https://chanhuiseok.github.io/posts/spring-3/)
